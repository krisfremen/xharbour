/*  $DOC$
 *  $FUNCNAME$
 *      FOR
 *  $CATEGORY$
 *      Statement
 *  $ONELINER$
 *      Execute a block of statements a specified number of times
 *  $SYNTAX$
 *      FOR <idCounter> := <nStart> TO <nEnd>
 *         [STEP <nIncrement>]
 *         <statements>...
 *         [EXIT]
 *         <statements>...
 *         [LOOP]
 *      NEXT
 *  $ARGUMENTS$
 *      <idCounter> is the name of the loop control or counter variable.  If
 *      the specified <idCounter> is not visible or does not exist, a private
 *      variable is created.
 *
 *      <nStart> is the initial value assigned to <idCounter>.  If
 *      <nIncrement> is negative, <nStart> must be less than <nEnd>.
 *
 *      TO <nEnd> defines the final value of <idCounter>.  If <nIncrement>
 *      is negative, <nStart> must be greater than <nEnd>; otherwise, <nStart>
 *      must be less than <nEnd>.
 *
 *      STEP <nIncrement> defines the amount <idCounter> is changed for each
 *      iteration of the loop.  <nIncrement> can be either positive or negative.
 *      If the STEP clause is not specified, <idCounter> is incremented by one
 *      for each iteration of the loop.
 *
 *      EXIT unconditionally branches control from within a FOR...NEXT
 *      construct to the statement immediately following the nearest NEXT
 *      statement.
 *
 *      LOOP branches control to the most recently executed FOR or DO WHILE
 *      statement.
 *
 *  $RETURNS$
 *      None
 *  $DESCRIPTION$
 *      FOR...NEXT is a control structure that executes a block of statements a
 *      specified number of times.  The control structure loops from the initial
 *      value of <idCounter> to the boundary specified by <nEnd>, moving through
 *      the range of values of the control variable for an increment specified
 *      by <nIncrement>.  All expressions in the FOR statement are reevaluated
 *      for each iteration of the loop.  The <nStart> and <nEnd> expressions,
 *      therefore, can be changed as the control structure operates.
 *  
 *      A FOR loop operates until <idCounter> is greater than <nEnd> or an EXIT
 *      statement is encountered.  Control then branches to the statement
 *      following the corresponding NEXT statement.  If a LOOP statement is
 *      encountered, control branches back to the current FOR statement.
 *  
 *      If <nIncrement> is a negative value, <idCounter> is decremented rather
 *      than incremented.  The FOR loop, however, continues until <idCounter> is
 *      less than <nEnd>.  This means that <nEnd> must be less than <nStart>
 *      when the FOR loop begins.
 *  
 *      FOR loops are useful for traversing arrays where <idCounter> is used as
 *      the array subscript.  See the example below.
 *  
 *      FOR...NEXT constructs may be nested within any other control structures
 *      to any depth.  The only requirement is that each control structure is
 *      properly nested.
 *  
 *  $EXAMPLES$
 *      .  This example traverses an array in ascending order:
 *
 *      nLenArray := LEN(aArray)
 *      FOR i := 1 TO nLenArray
 *         <statements>...
 *      NEXT
 *
 *      .  To traverse an array in descending order:
 *
 *      nLenArray := LEN(aArray)
 *      FOR i := nLenArray TO 1 STEP -1
 *         <statements>...
 *      NEXT
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This is Clipper compliant
 *  $PLATFORMS$
 *      All
 *  $SEEALSO$
 *      WHILE,FOR EACH,IF
 *  $END$
 */
/*  $DOC$
 *  $FUNCNAME$
 *      FUNCTION
 *  $CATEGORY$
 *      Statement
 *  $ONELINER$
 *      Declare a user-defined function name and formal parameters
 *  $SYNTAX$
 *      [STATIC] FUNCTION <idFunction>[(<idParam list>)]
 *      [LOCAL <identifier> [[:= <initializer>], ... ]]
 *      [STATIC <identifier> [[:= <initializer>], ... ]]
 *      [FIELD <identifier list> [IN <idAlias>]]
 *      [MEMVAR <identifier list>]
 *      .
 *      . <executable statements>
 *      .
 *      RETURN <exp>
 *  $ARGUMENTS$
 *      <idFunction> is the name of the user-defined function to be
 *      declared.  User-defined function names can be any length, but only the
 *      first 10 characters are significant.  Names can contain any combination
 *      of characters, numbers, or underscores, but must begin with a character
 *      or an underscore.  Leading underscores are not recommended since they
 *      are reserved for internal functions.
 *  
 *      <idParam list> is the declaration of one or more parameter
 *      variables.  Variables specified in this list are declared local.
 *  
 *      STATIC FUNCTION declares a user-defined function that can be invoked
 *      only by procedures and user-defined functions declared in the same
 *      program (.prg) file.
 *  
 *      LOCAL declares and optionally initializes a list of variables or
 *      arrays whose visibility and lifetime is the current function.
 *  
 *      STATIC declares and optionally initializes a list of variables or
 *      arrays whose visibility is the current user-defined function and
 *      lifetime is the duration of the program.
 *  
 *      FIELD declares a list of identifiers to use as field names whenever
 *      encountered.  If the IN clause is specified, referring to the declared
 *      name includes an implicit reference to the specified alias.
 *  
 *      MEMVAR declares a list of identifiers to use as private or public
 *      memory variables or arrays whenever encountered.
 *  
 *      <identifier> and <identifier list> are labels to be used as
 *      variable or array names.
 *  
 *      <initializer> is a value to which an array or variable is originally
 *      set in an inline expression.
 *  
 *      RETURN <exp> passes control back to the calling procedure or
 *      user-defined function, returning the result of <exp> as the value of the
 *      function.  Each function must have at least one RETURN statement that
 *      returns a value.  RETURN statements can occur anywhere in the body of a
 *      function.
 *  $RETURNS$
 *      <exp> The value especified on RETURN <exp>
 *  $DESCRIPTION$
 *      The FUNCTION statement declares a user-defined function and an optional
 *      list of local variables to receive parameters often referred to as
 *      formal parameters.  A user-defined function is a subprogram comprised of
 *      a set of declarations and statements executed whenever you refer to
 *      <idFunction> followed by an open and closed parentheses pair.  A function
 *      definition begins with a FUNCTION statement which is the FUNCTION
 *      declaration and ends with the next FUNCTION statement, PROCEDURE
 *      statement, or end of file.
 *  
 *      Functions encapsulate a computational block of code and then later
 *      create expressions using the value returned.  Functions and procedures
 *      increase both readability and modularity, isolate change, and help
 *      manage complexity.
 *  
 *      A function in CA-Clipper is the same as a procedure, except that it must
 *      return a value.  The returned value can be any data type including an
 *      array, a code block, or NIL.  Each function must begin with a FUNCTION
 *      statement and contain at least one RETURN statement with an argument.
 *      Function declarations cannot be nested within other function
 *      definitions.  A user-defined function can be used wherever standard
 *      functions are supported, including expressions.
 *  
 *      The visibility of function names falls into two classes.  Functions that
 *      are visible anywhere in a program are referred to as public functions
 *      and declared with a FUNCTION statement.  Functions that are visible only
 *      within the current program (.prg) file are referred to as static
 *      functions and declared with a STATIC FUNCTION statement.  Static
 *      functions have filewide scope.
 *  
 *      Static functions limit visibility of a function name, thereby
 *      restricting access to the function.  Because of this, subsystems defined
 *      within a single program (.prg) file can provide an access protocol with
 *      a series of public functions and conceal the implementation details of
 *      the subsystem within static functions and procedures.  Since the static
 *      function references are resolved at compile time, they preempt
 *      references to public functions which are resolved at link time.  This
 *      ensures that within a program file, a reference to a static function
 *      executes that function if there is a name conflict with a public
 *      function.
 *  $EXAMPLES$
 *      FUNCTION SUM(x,y)
 *      RETURN x+y
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This is Clipper compliant
 *  $PLATFORMS$
 *      All
 *  $SEEALSO$
 *      LOCAL,PARAMETERS,PCOUNT(),PRIVATE,PROCEDURE,RETURN 
 *  $END$
 */
