#ifndef _REGEX_H_
#define	_REGEX_H_	/* never again */

// utils.h
/* utility definitions */
#ifdef _POSIX2_RE_DUP_MAX
#define DUPMAX  _POSIX2_RE_DUP_MAX
#else
#define DUPMAX  255
#endif
#define INFINITY    (DUPMAX + 1)
#define NC      (CHAR_MAX - CHAR_MIN + 1)
typedef unsigned char uch;

/* switch off assertions (if not already off) if no REDEBUG */
#ifndef REDEBUG
#ifndef NDEBUG
#define NDEBUG  /* no assertions please */
#endif
#endif

/* for old systems with bcopy() but no memmove() */
#ifdef USEBCOPY
#define memmove(d, s, c)    bcopy(s, d, c)
#endif

/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === regex2.h === */
typedef off_t regoff_t;
typedef struct {
	int re_magic;
	size_t re_nsub;		/* number of parenthesized subexpressions */
	const char *re_endp;	/* end pointer for REG_PEND */
	struct re_guts *re_g;	/* none of your business :-) */
} regex_t;
typedef struct {
	regoff_t rm_so;		/* start of match */
	regoff_t rm_eo;		/* end of match */
} regmatch_t;


/* === regcomp.c === */
extern int regcomp(regex_t *, const char *, int);
#define	REG_BASIC	0000
#define	REG_EXTENDED	0001
#define	REG_ICASE	0002
#define	REG_NOSUB	0004
#define	REG_NEWLINE	0010
#define	REG_NOSPEC	0020
#define	REG_PEND	0040
#define	REG_DUMP	0200


/* === regerror.c === */
#define	REG_OKAY	 0
#define	REG_NOMATCH	 1
#define	REG_BADPAT	 2
#define	REG_ECOLLATE	 3
#define	REG_ECTYPE	 4
#define	REG_EESCAPE	 5
#define	REG_ESUBREG	 6
#define	REG_EBRACK	 7
#define	REG_EPAREN	 8
#define	REG_EBRACE	 9
#define	REG_BADBR	10
#define	REG_ERANGE	11
#define	REG_ESPACE	12
#define	REG_BADRPT	13
#define	REG_EMPTY	14
#define	REG_ASSERT	15
#define	REG_INVARG	16
#define	REG_ATOI	255	/* convert name to number (!) */
#define	REG_ITOA	0400	/* convert number to name (!) */
extern size_t regerror(int, const regex_t *, char *, size_t);


/* === regexec.c === */
extern int regexec(const regex_t *, const char *, size_t, regmatch_t [], int);
#define	REG_NOTBOL	00001
#define	REG_NOTEOL	00002
#define	REG_STARTEND	00004
#define	REG_TRACE	00400	/* tracing of execution */
#define	REG_LARGE	01000	/* force large representation */
#define	REG_BACKR	02000	/* force use of backref code */


/* === regfree.c === */
extern void regfree(regex_t *);

#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */
#endif

// regex2.h
/*
 * First, the stuff that ends up in the outside-world include file
 = typedef off_t regoff_t;
 = typedef struct {
 =  int re_magic;
 =  size_t re_nsub;     // number of parenthesized subexpressions
 =  const char *re_endp;    // end pointer for REG_PEND
 =  struct re_guts *re_g;   // none of your business :-)
 = } regex_t;
 = typedef struct {
 =  regoff_t rm_so;     // start of match
 =  regoff_t rm_eo;     // end of match
 = } regmatch_t;
 */
/*
 * internals of regex_t
 */
#define MAGIC1  ((('r'^0200)<<8) | 'e')

/*
 * The internal representation is a *strip*, a sequence of
 * operators ending with an endmarker.  (Some terminology etc. is a
 * historical relic of earlier versions which used multiple strips.)
 * Certain oddities in the representation are there to permit running
 * the machinery backwards; in particular, any deviation from sequential
 * flow must be marked at both its source and its destination.  Some
 * fine points:
 *
 * - OPLUS_ and O_PLUS are *inside* the loop they create.
 * - OQUEST_ and O_QUEST are *outside* the bypass they create.
 * - OCH_ and O_CH are *outside* the multi-way branch they create, while
 *   OOR1 and OOR2 are respectively the end and the beginning of one of
 *   the branches.  Note that there is an implicit OOR2 following OCH_
 *   and an implicit OOR1 preceding O_CH.
 *
 * In state representations, an operator's bit is on to signify a state
 * immediately *preceding* "execution" of that operator.
 */
typedef long sop;       /* strip operator */
typedef long sopno;
#define OPRMASK 0x7c000000
#define OPDMASK 0x03ffffff
#define OPSHIFT (26)
#define OP(n)   ((n)&OPRMASK)
#define OPND(n) ((n)&OPDMASK)
#define SOP(op, opnd)   ((op)|(opnd))
/* operators               meaning  operand         */
/*                      (back, fwd are offsets) */
#define OEND    (1<<OPSHIFT)    /* endmarker    -           */
#define OCHAR   (2<<OPSHIFT)    /* character    unsigned char       */
#define OBOL    (3<<OPSHIFT)    /* left anchor  -           */
#define OEOL    (4<<OPSHIFT)    /* right anchor -           */
#define OANY    (5<<OPSHIFT)    /* .        -           */
#define OANYOF  (6<<OPSHIFT)    /* [...]    set number      */
#define OBACK_  (7<<OPSHIFT)    /* begin \d paren number        */
#define O_BACK  (8<<OPSHIFT)    /* end \d   paren number        */
#define OPLUS_  (9<<OPSHIFT)    /* + prefix fwd to suffix       */
#define O_PLUS  (10<<OPSHIFT)   /* + suffix back to prefix      */
#define OQUEST_ (11<<OPSHIFT)   /* ? prefix fwd to suffix       */
#define O_QUEST (12<<OPSHIFT)   /* ? suffix back to prefix      */
#define OLPAREN (13<<OPSHIFT)   /* (        fwd to )        */
#define ORPAREN (14<<OPSHIFT)   /* )        back to (       */
#define OCH_    (15<<OPSHIFT)   /* begin choice fwd to OOR2     */
#define OOR1    (16<<OPSHIFT)   /* | pt. 1  back to OOR1 or OCH_    */
#define OOR2    (17<<OPSHIFT)   /* | pt. 2  fwd to OOR2 or O_CH */
#define O_CH    (18<<OPSHIFT)   /* end choice   back to OOR1        */
#define OBOW    (19<<OPSHIFT)   /* begin word   -           */
#define OEOW    (20<<OPSHIFT)   /* end word -           */

/*
 * Structure for [] character-set representation.  Character sets are
 * done as bit vectors, grouped 8 to a byte vector for compactness.
 * The individual set therefore has both a pointer to the byte vector
 * and a mask to pick out the relevant bit of each byte.  A hash code
 * simplifies testing whether two sets could be identical.
 *
 * This will get trickier for multicharacter collating elements.  As
 * preliminary hooks for dealing with such things, we also carry along
 * a string of multi-character elements, and decide the size of the
 * vectors at run time.
 */
typedef struct {
    uch *ptr;       /* -> uch [csetsize] */
    uch mask;       /* bit within array */
    uch hash;       /* hash code */
    size_t smultis;
    char *multis;       /* -> char[smulti]  ab\0cd\0ef\0\0 */
} cset;
/* note that CHadd and CHsub are unsafe, and CHIN doesn't yield 0/1 */
#define CHadd(cs, c)    ((cs)->ptr[(uch)(c)] |= (cs)->mask, (cs)->hash += (c))
#define CHsub(cs, c)    ((cs)->ptr[(uch)(c)] &= ~(cs)->mask, (cs)->hash -= (c))
#define CHIN(cs, c) ((cs)->ptr[(uch)(c)] & (cs)->mask)
#define MCadd(p, cs, cp)    mcadd(p, cs, cp)    /* regcomp() internal fns */
#define MCsub(p, cs, cp)    mcsub(p, cs, cp)
#define MCin(p, cs, cp) mcin(p, cs, cp)

/* stuff for character categories */
typedef unsigned char cat_t;

/*
 * main compiled-expression structure
 */
struct re_guts {
    int magic;
#       define  MAGIC2  ((('R'^0200)<<8)|'E')
    sop *strip;     /* malloced area for strip */
    int csetsize;       /* number of bits in a cset vector */
    int ncsets;     /* number of csets in use */
    cset *sets;     /* -> cset [ncsets] */
    uch *setbits;       /* -> uch[csetsize][ncsets/CHAR_BIT] */
    int cflags;     /* copy of regcomp() cflags argument */
    sopno nstates;      /* = number of sops */
    sopno firststate;   /* the initial OEND (normally 0) */
    sopno laststate;    /* the final OEND */
    int iflags;     /* internal flags */
#       define  USEBOL  01  /* used ^ */
#       define  USEEOL  02  /* used $ */
#       define  BAD 04  /* something wrong */
    int nbol;       /* number of ^ used */
    int neol;       /* number of $ used */
    int ncategories;    /* how many character categories */
    cat_t *categories;  /* ->catspace[-CHAR_MIN] */
    char *must;     /* match must contain this string */
    int mlen;       /* length of must */
    size_t nsub;        /* copy of re_nsub */
    int backrefs;       /* does it use back references? */
    sopno nplus;        /* how deep does it nest +s? */
    /* catspace must be last */
    cat_t catspace[1];  /* actually [NC] */
};

/* misc utilities */
#define OUT (CHAR_MAX+1)    /* a non-character value */
#define ISWORD(c)   (isalnum(c) || (c) == '_')

// cname.h
/* character-name table */
static struct cname {
    char *name;
    char code;
} cnames[] = {
    "NUL",  '\0',
    "SOH",  '\001',
    "STX",  '\002',
    "ETX",  '\003',
    "EOT",  '\004',
    "ENQ",  '\005',
    "ACK",  '\006',
    "BEL",  '\007',
    "alert",    '\007',
    "BS",       '\010',
    "backspace",    '\b',
    "HT",       '\011',
    "tab",      '\t',
    "LF",       '\012',
    "newline",  '\n',
    "VT",       '\013',
    "vertical-tab", '\v',
    "FF",       '\014',
    "form-feed",    '\f',
    "CR",       '\015',
    "carriage-return",  '\r',
    "SO",   '\016',
    "SI",   '\017',
    "DLE",  '\020',
    "DC1",  '\021',
    "DC2",  '\022',
    "DC3",  '\023',
    "DC4",  '\024',
    "NAK",  '\025',
    "SYN",  '\026',
    "ETB",  '\027',
    "CAN",  '\030',
    "EM",   '\031',
    "SUB",  '\032',
    "ESC",  '\033',
    "IS4",  '\034',
    "FS",   '\034',
    "IS3",  '\035',
    "GS",   '\035',
    "IS2",  '\036',
    "RS",   '\036',
    "IS1",  '\037',
    "US",   '\037',
    "space",        ' ',
    "exclamation-mark", '!',
    "quotation-mark",   '"',
    "number-sign",      '#',
    "dollar-sign",      '$',
    "percent-sign",     '%',
    "ampersand",        '&',
    "apostrophe",       '\'',
    "left-parenthesis", '(',
    "right-parenthesis",    ')',
    "asterisk", '*',
    "plus-sign",    '+',
    "comma",    ',',
    "hyphen",   '-',
    "hyphen-minus", '-',
    "period",   '.',
    "full-stop",    '.',
    "slash",    '/',
    "solidus",  '/',
    "zero",     '0',
    "one",      '1',
    "two",      '2',
    "three",    '3',
    "four",     '4',
    "five",     '5',
    "six",      '6',
    "seven",    '7',
    "eight",    '8',
    "nine",     '9',
    "colon",    ':',
    "semicolon",    ';',
    "less-than-sign",   '<',
    "equals-sign",      '=',
    "greater-than-sign",    '>',
    "question-mark",    '?',
    "commercial-at",    '@',
    "left-square-bracket",  '[',
    "backslash",        '\\',
    "reverse-solidus",  '\\',
    "right-square-bracket", ']',
    "circumflex",       '^',
    "circumflex-accent",    '^',
    "underscore",       '_',
    "low-line",     '_',
    "grave-accent",     '`',
    "left-brace",       '{',
    "left-curly-bracket",   '{',
    "vertical-line",    '|',
    "right-brace",      '}',
    "right-curly-bracket",  '}',
    "tilde",        '~',
    "DEL",  '\177',
    NULL,   0,
};

// cclass.h
/* character-class table */
static struct cclass {
    char *name;
    char *chars;
    char *multis;
} cclasses[] = {
    "alnum",    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\
0123456789",                "",
    "alpha",    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
                    "",
    "blank",    " \t",      "",
    "cntrl",    "\007\b\t\n\v\f\r\1\2\3\4\5\6\16\17\20\21\22\23\24\
\25\26\27\30\31\32\33\34\35\36\37\177", "",
    "digit",    "0123456789",   "",
    "graph",    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\
0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
                    "",
    "lower",    "abcdefghijklmnopqrstuvwxyz",
                    "",
    "print",    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\
0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ ",
                    "",
    "punct",    "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
                    "",
    "space",    "\t\n\v\f\r ",  "",
    "upper",    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    "",
    "xdigit",   "0123456789ABCDEFabcdef",
                    "",
    NULL,       0,      ""
};
